(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{460:function(t,a,s){t.exports=s.p+"assets/img/fasthttp_read.2dd800ce.jpg"},482:function(t,a,s){"use strict";s.r(a);var e=s(8),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"起因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#起因"}},[t._v("#")]),t._v(" 起因")]),t._v(" "),e("p",[t._v("近期由于新上的一个系统新版本出现了 bug，现象是某个 HTTP 接口会在接受一定量请求之后 hang 住，伴随着产生了大量调用方的超时报警。由于新上的系统不是面向用户的系统，所以要求运维保留现场，关掉了触发问题请求的任务，开始排查问题。")]),t._v(" "),e("p",[t._v("最后找到问题的原因很简单：sqlx 库使用了 Queryx 方法，查询由于只是判断记录是否存在，所以并没有读取返回的 Rows，这就导致了一个问题，就是数据库连接不会被释放回池子里，由于设置了最大连接数，所以导致接口被 hang 死。")]),t._v(" "),e("p",[t._v("这里也有了一个教训，无论是什么级别的系统，还是在测试环境多跑跑。")]),t._v(" "),e("p",[t._v("言归正传，今天要讨论的主题并不是这个低级错误。在修复完 bug 之后，由于之前的服务一直保留现场，所以修复的代码打包完成后直接在公司内部的 k8s 平台操作上线了，这时产生了一个诡异的现象，突然之间收到了大约三千多个请求，似乎是之前被 hang 住的请求被复活一样。")]),t._v(" "),e("p",[t._v("这就诡异了。")]),t._v(" "),e("p",[t._v("接下来就是搞清楚这个问题，比较担心是某些未知的 bug 导致的。")]),t._v(" "),e("h2",{attrs:{id:"问题探究"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题探究"}},[t._v("#")]),t._v(" 问题探究")]),t._v(" "),e("p",[t._v("我先从这三千多个请求中随机挑选了几个，由于每个请求都有 TraceId，所以直接去请求方日志中搜寻，发现这些请求的确是在故障发生时候请求的，并且还有请求超时的错误信息。在服务修复之后上线重启的时间段，并没有对应的请求日志。")]),t._v(" "),e("p",[t._v("由于有请求服务的代码权限，所以直接拉取代码，想直接在代码中找找线索。排查过程中发现，调用方服务 HTTP 请求是使用的 fasthttp 库，代码也很简单，核心逻辑如下：")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[t._v("fasthttp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("DoTimeout")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("req"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" resp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" time"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Second"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("代码中设置了超时时间，隐约的感觉这个问题应该和 fasthttp 库有关。接下来就是看一下 fasthttp 的代码，果然发现了一处重试逻辑：\n"),e("a",{attrs:{href:"https://github.com/valyala/fasthttp/blob/v1.19.0/client.go#L1231",target:"_blank",rel:"noopener noreferrer"}},[t._v("client.go#L1231"),e("OutboundLink")],1)]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  retry"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("do")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("req"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" resp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("retry "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" hasBodyStream "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("isRequestRetryable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("req"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" io"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EOF "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  attempts"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" attempts "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" maxAttempts "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("当服务重启的时，"),e("code",[t._v("c.do()")]),t._v(" 返回 "),e("code",[t._v("retry=true，err=io.EOF")]),t._v("，fasthttp 会触发重试逻辑。当再次重试的时候，可能已经请求到重启之后的服务了，这里要说一下，这个过程在本地不是特别好复现，一般情况下，k8s 都是滚动发布，先拉起新的服务，服务探活正常，然后会把依次把旧的服务下线，旧服务下线时，调用方会收到 io.EOF。新的服务注册到负载均衡或者服务发现上，也就是平滑重启，所以这个时候 fasthttp 进行 retry 直接请求到正常服务上。")]),t._v(" "),e("p",[e("code",[t._v("do()")]),t._v(" 函数内部产生 "),e("code",[t._v("retry=true，err=io.EOF")]),t._v(" 返回结果的位置代码逻辑如下：\n"),e("a",{attrs:{href:"https://github.com/valyala/fasthttp/blob/v1.19.0/client.go#L1383",target:"_blank",rel:"noopener noreferrer"}},[t._v("client.go#L1383"),e("OutboundLink")],1)]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[t._v("br "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireReader")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("conn"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" resp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("ReadLimitBody")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("br"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MaxResponseBodySize"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("releaseReader")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("br"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("closeConn")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  retry "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" ErrBodyTooLarge\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" retry"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("实际上，每个请求都会阻塞在 ReadLimitBody，也就是读取服务端响应数据的这行，直到服务重启。这个时候就如上面所说的，触发重试逻辑。")]),t._v(" "),e("p",[t._v("之所以会阻塞直到服务端重启，是因为没有设置连接的 ReadTimeout（TCP 的超时设置），默认情况下，fasthttp 这个选项是 0，也就是没有限制，会无限等待下去。但是如果这里设置了 ReadTimeout 的时间，其实还是会重试，只是会在重试超过 maxAttempts（默认为 5） 次数之后退出请求。如果不想进行重试，需要设置 fasthttp.Client 的 RetryIf 函数。")]),t._v(" "),e("p",[t._v("关于设置 ReadTimeout 的问题 fasthttp 在 DoTimeout 方法上也有相关的注释：")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Warning: DoTimeout does not terminate the request itself. The request will")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// continue in the background and the response will be discarded.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// If requests take too long and the connection pool gets filled up please")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// try using a Client and setting a ReadTimeout.")]),t._v("\n")])])]),e("h2",{attrs:{id:"go-http-标准库的重试逻辑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#go-http-标准库的重试逻辑"}},[t._v("#")]),t._v(" Go HTTP 标准库的重试逻辑")]),t._v(" "),e("p",[t._v("之后我也简单研究了一下标准库的重试逻辑，代码位置在：\n"),e("a",{attrs:{href:"https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L661",target:"_blank",rel:"noopener noreferrer"}},[t._v("transport.go#L661"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("Go 标准库会在如下情况下进行重试：")]),t._v(" "),e("ol",[e("li",[t._v("http2 相关，具体参考 "),e("a",{attrs:{href:"https://github.com/golang/go/issues/16582",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues/16582"),e("OutboundLink")],1)]),t._v(" "),e("li",[t._v("请求是可重试的并且 Transport 在读取 Response 第一个 byte 的时候出错")]),t._v(" "),e("li",[t._v("请求是可重试的并且 Transport 新建立的 TCP 链接在没有请求的情况下返回了 io.EOF 或者读取到了 HTTP 408，这部分逻辑在："),e("a",{attrs:{href:"https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2186",target:"_blank",rel:"noopener noreferrer"}},[t._v("transport.go#L2186"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("上述后面两点主逻辑代码在 persistConn.readLoop 函数内：\n"),e("a",{attrs:{href:"https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2005",target:"_blank",rel:"noopener noreferrer"}},[t._v("transport.go#L2005"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("标准库对于可重试的定义代码：\n"),e("a",{attrs:{href:"https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/request.go#L1392",target:"_blank",rel:"noopener noreferrer"}},[t._v("request.go#L1392"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"goroutine-泄漏问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#goroutine-泄漏问题"}},[t._v("#")]),t._v(" goroutine 泄漏问题")]),t._v(" "),e("p",[t._v("如果 HTTP 请求未设置 TCP 级别读取或者写入的超时时间，读取或者写入的 goroutine 便会永远阻塞，无法被复用，这时候如果有新请求会建立新的连接，也算是产生 goroutine 泄漏。")]),t._v(" "),e("p",[t._v("请求库的超时设置本质上只是库级别的一个 timer，不对下层 TCP 起作用。")]),t._v(" "),e("p",[e("strong",[t._v("但是标准库并不会产生泄漏问题")]),t._v("，当请求超时的时候，标准库会直接关闭 TCP 链接，这部分代码在：\n"),e("a",{attrs:{href:"https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2656",target:"_blank",rel:"noopener noreferrer"}},[t._v("transport.go#L2608"),e("OutboundLink")],1),t._v("、\n"),e("a",{attrs:{href:"https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2656",target:"_blank",rel:"noopener noreferrer"}},[t._v("transport.go#L2656"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("fasthttp 就没用这么幸运了，并没有这个机制，所以 fasthttp 只能通过设置 TCP 的超时来解决。")]),t._v(" "),e("p",[t._v("fasthttp 被阻塞的 goroutine：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(460),alt:"fasthttp"}})]),t._v(" "),e("h2",{attrs:{id:"最后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[t._v("#")]),t._v(" 最后")]),t._v(" "),e("ul",[e("li",[t._v("fasthttp 版本：v1.19.0")]),t._v(" "),e("li",[t._v("go 版本：1.15")])]),t._v(" "),e("p",[t._v("问题定位工具&思路：")]),t._v(" "),e("ul",[e("li",[t._v("使用 net/http/pprof 查看 goroutine 信息，确定是否存在泄漏，并且可查看 stack")]),t._v(" "),e("li",[t._v("通过以上方法确认标准库没有泄漏，首先通过 Wireshark 抓取 Loopback 网卡数据包，过滤端口定位是客户端在超时之后关闭了 TCP 链接（发送了 FIN 帧）")]),t._v(" "),e("li",[t._v("给标准库 http.Client 设置自定义的 http.Transport，Transport 内设置的 DialContext 返回的 net.Conn 继承重写了 Close 方法，重写的 Close 打上断点，方便调试定位代码位置（HTTP 标准库代码实在是太多了。。）")])])])}),[],!1,null,null,null);a.default=n.exports}}]);