<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从一次线上问题排查发现的 fasthttp 设置问题 | 时间之外，地球往事</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="

近期由于新上的一个系统新版本出现了 bug，现象是某个 HTTP 接口会在接受一定量请求之后 hang 住，伴随着产生了大量调用方的超时报警。由于新上的系统不是面向用户的系统，所以要求运维保留现场，关掉了触发问题请求的任务，开始排查问题。

最后找到问题的原因很简单：sqlx 库使用了 Queryx 方法，查询由于只是判断记录是否存在，所以并没有读取返回的 Rows，这就导致了一个问题，就是数 ...">
    
    <link rel="preload" href="/assets/css/0.styles.905f592a.css" as="style"><link rel="preload" href="/assets/js/app.fdefdbc6.js" as="script"><link rel="preload" href="/assets/js/6.a2e33591.js" as="script"><link rel="preload" href="/assets/js/3.f010fe40.js" as="script"><link rel="preload" href="/assets/js/9.e501de50.js" as="script"><link rel="prefetch" href="/assets/js/10.bf6c3a7a.js"><link rel="prefetch" href="/assets/js/11.348cfa3d.js"><link rel="prefetch" href="/assets/js/12.28d58ffd.js"><link rel="prefetch" href="/assets/js/13.c2784cb3.js"><link rel="prefetch" href="/assets/js/14.14af0309.js"><link rel="prefetch" href="/assets/js/15.08ef0429.js"><link rel="prefetch" href="/assets/js/16.0abe5246.js"><link rel="prefetch" href="/assets/js/17.5f4e01c2.js"><link rel="prefetch" href="/assets/js/4.b1c71721.js"><link rel="prefetch" href="/assets/js/5.f4f06ddc.js"><link rel="prefetch" href="/assets/js/7.6f757cfa.js"><link rel="prefetch" href="/assets/js/8.5485783b.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.d563de98.js">
    <link rel="stylesheet" href="/assets/css/0.styles.905f592a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">时间之外，地球往事 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="/about.html" class="nav-link">About</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">时间之外，地球往事 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="/about.html" class="nav-link">About</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        从一次线上问题排查发现的 fasthttp 设置问题
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">徐徐</span> <span itemprop="address">   in Beijing</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-01-12T00:00:00.000Z">
      2021-01-12
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/Go" data-v-42ccfcd5><span data-v-42ccfcd5>Go</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/编程" data-v-42ccfcd5><span data-v-42ccfcd5>编程</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/fasthttp" data-v-42ccfcd5><span data-v-42ccfcd5>fasthttp</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="起因"><a href="#起因" class="header-anchor">#</a> 起因</h2> <p>近期由于新上的一个系统新版本出现了 bug，现象是某个 HTTP 接口会在接受一定量请求之后 hang 住，伴随着产生了大量调用方的超时报警。由于新上的系统不是面向用户的系统，所以要求运维保留现场，关掉了触发问题请求的任务，开始排查问题。</p> <p>最后找到问题的原因很简单：sqlx 库使用了 Queryx 方法，查询由于只是判断记录是否存在，所以并没有读取返回的 Rows，这就导致了一个问题，就是数据库连接不会被释放回池子里，由于设置了最大连接数，所以导致接口被 hang 死。</p> <p>这里也有了一个教训，无论是什么级别的系统，还是在测试环境多跑跑。</p> <p>言归正传，今天要讨论的主题并不是这个低级错误。在修复完 bug 之后，由于之前的服务一直保留现场，所以修复的代码打包完成后直接在公司内部的 k8s 平台操作上线了，这时产生了一个诡异的现象，突然之间收到了大约三千多个请求，似乎是之前被 hang 住的请求被复活一样。</p> <p>这就诡异了。</p> <p>接下来就是搞清楚这个问题，比较担心是某些未知的 bug 导致的。</p> <h2 id="问题探究"><a href="#问题探究" class="header-anchor">#</a> 问题探究</h2> <p>我先从这三千多个请求中随机挑选了几个，由于每个请求都有 TraceId，所以直接去请求方日志中搜寻，发现这些请求的确是在故障发生时候请求的，并且还有请求超时的错误信息。在服务修复之后上线重启的时间段，并没有对应的请求日志。</p> <p>由于有请求服务的代码权限，所以直接拉取代码，想直接在代码中找找线索。排查过程中发现，调用方服务 HTTP 请求是使用的 fasthttp 库，代码也很简单，核心逻辑如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>fasthttp<span class="token punctuation">.</span><span class="token function">DoTimeout</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>代码中设置了超时时间，隐约的感觉这个问题应该和 fasthttp 库有关。接下来就是看一下 fasthttp 的代码，果然发现了一处重试逻辑：
<a href="https://github.com/valyala/fasthttp/blob/v1.19.0/client.go#L1231" target="_blank" rel="noopener noreferrer">client.go#L1231<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">for</span> <span class="token punctuation">{</span>
  retry<span class="token punctuation">,</span> err <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">do</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span>
  <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token operator">!</span>retry <span class="token punctuation">{</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> hasBodyStream <span class="token punctuation">{</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isRequestRetryable</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  attempts<span class="token operator">++</span>
  <span class="token keyword">if</span> attempts <span class="token operator">&gt;=</span> maxAttempts <span class="token punctuation">{</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>当服务重启的时，<code>c.do()</code> 返回 <code>retry=true，err=io.EOF</code>，fasthttp 会触发重试逻辑。当再次重试的时候，可能已经请求到重启之后的服务了，这里要说一下，这个过程在本地不是特别好复现，一般情况下，k8s 都是滚动发布，先拉起新的服务，服务探活正常，然后会把依次把旧的服务下线，旧服务下线时，调用方会收到 io.EOF。新的服务注册到负载均衡或者服务发现上，也就是平滑重启，所以这个时候 fasthttp 进行 retry 直接请求到正常服务上。</p> <p><code>do()</code> 函数内部产生 <code>retry=true，err=io.EOF</code> 返回结果的位置代码逻辑如下：
<a href="https://github.com/valyala/fasthttp/blob/v1.19.0/client.go#L1383" target="_blank" rel="noopener noreferrer">client.go#L1383<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>br <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">acquireReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">ReadLimitBody</span><span class="token punctuation">(</span>br<span class="token punctuation">,</span> c<span class="token punctuation">.</span>MaxResponseBodySize<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
  c<span class="token punctuation">.</span><span class="token function">releaseReader</span><span class="token punctuation">(</span>br<span class="token punctuation">)</span>
  c<span class="token punctuation">.</span><span class="token function">closeConn</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span>
  retry <span class="token operator">:=</span> err <span class="token operator">!=</span> ErrBodyTooLarge
  <span class="token keyword">return</span> retry<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>实际上，每个请求都会阻塞在 ReadLimitBody，也就是读取服务端响应数据的这行，直到服务重启。这个时候就如上面所说的，触发重试逻辑。</p> <p>之所以会阻塞直到服务端重启，是因为没有设置连接的 ReadTimeout（TCP 的超时设置），默认情况下，fasthttp 这个选项是 0，也就是没有限制，会无限等待下去。但是如果这里设置了 ReadTimeout 的时间，其实还是会重试，只是会在重试超过 maxAttempts（默认为 5） 次数之后退出请求。如果不想进行重试，需要设置 fasthttp.Client 的 RetryIf 函数。</p> <p>关于设置 ReadTimeout 的问题 fasthttp 在 DoTimeout 方法上也有相关的注释：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Warning: DoTimeout does not terminate the request itself. The request will</span>
<span class="token comment">// continue in the background and the response will be discarded.</span>
<span class="token comment">// If requests take too long and the connection pool gets filled up please</span>
<span class="token comment">// try using a Client and setting a ReadTimeout.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="go-http-标准库的重试逻辑"><a href="#go-http-标准库的重试逻辑" class="header-anchor">#</a> Go HTTP 标准库的重试逻辑</h2> <p>之后我也简单研究了一下标准库的重试逻辑，代码位置在：
<a href="https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L661" target="_blank" rel="noopener noreferrer">transport.go#L661<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Go 标准库会在如下情况下进行重试：</p> <ol><li>http2 相关，具体参考 <a href="https://github.com/golang/go/issues/16582" target="_blank" rel="noopener noreferrer">issues/16582<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>请求是可重试的并且 Transport 在读取 Response 第一个 byte 的时候出错</li> <li>请求是可重试的并且 Transport 新建立的 TCP 链接在没有请求的情况下返回了 io.EOF 或者读取到了 HTTP 408，这部分逻辑在：<a href="https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2186" target="_blank" rel="noopener noreferrer">transport.go#L2186<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <p>上述后面两点主逻辑代码在 persistConn.readLoop 函数内：
<a href="https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2005" target="_blank" rel="noopener noreferrer">transport.go#L2005<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>标准库对于可重试的定义代码：
<a href="https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/request.go#L1392" target="_blank" rel="noopener noreferrer">request.go#L1392<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="goroutine-泄漏问题"><a href="#goroutine-泄漏问题" class="header-anchor">#</a> goroutine 泄漏问题</h2> <p>如果 HTTP 请求未设置 TCP 级别读取或者写入的超时时间，读取或者写入的 goroutine 便会永远阻塞，无法被复用，这时候如果有新请求会建立新的连接，也算是产生 goroutine 泄漏。</p> <p>请求库的超时设置本质上只是库级别的一个 timer，不对下层 TCP 起作用。</p> <p><strong>但是标准库并不会产生泄漏问题</strong>，当请求超时的时候，标准库会直接关闭 TCP 链接，这部分代码在：
<a href="https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2656" target="_blank" rel="noopener noreferrer">transport.go#L2608<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、
<a href="https://github.com/golang/go/blob/release-branch.go1.15/src/net/http/transport.go#L2656" target="_blank" rel="noopener noreferrer">transport.go#L2656<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>fasthttp 就没用这么幸运了，并没有这个机制，所以 fasthttp 只能通过设置 TCP 的超时来解决。</p> <p>fasthttp 被阻塞的 goroutine：</p> <p><img src="/assets/img/fasthttp_read.2dd800ce.jpg" alt="fasthttp"></p> <h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>相关版本</p> <ul><li>fasthttp 版本：v1.19.0</li> <li>go 版本：1.15</li></ul> <p>问题定位工具&amp;思路：</p> <ul><li>使用 net/http/pprof 查看 goroutine 信息，确定是否存在泄漏，并且可查看 stack</li> <li>通过以上方法确认标准库没有泄漏，首先通过 Wireshark 抓取 Loopback 网卡数据包，过滤端口定位是客户端在超时之后关闭了 TCP 链接（发送了 FIN 帧）</li> <li>给标准库 http.Client 设置自定义的 http.Transport，Transport 内设置的 DialContext 返回的 net.Conn 继承重写了 Close 方法，重写的 Close 打上断点，方便调试定位代码位置（HTTP 标准库代码实在是太多了。。）</li></ul></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#起因" title="起因">起因</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#问题探究" title="问题探究">问题探究</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#go-http-标准库的重试逻辑" title="Go HTTP 标准库的重试逻辑">Go HTTP 标准库的重试逻辑</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#goroutine-泄漏问题" title="goroutine 泄漏问题">goroutine 泄漏问题</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#最后" title="最后">最后</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/shijianzhiwai/" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.fdefdbc6.js" defer></script><script src="/assets/js/6.a2e33591.js" defer></script><script src="/assets/js/3.f010fe40.js" defer></script><script src="/assets/js/9.e501de50.js" defer></script>
  </body>
</html>
