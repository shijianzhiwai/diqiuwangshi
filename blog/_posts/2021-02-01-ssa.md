---
tags: 
  - Go
  - SSA
  - 编译器
title: Go 编译器 SSA 中间代码探究
date: 2021-02-01
author: 徐徐
location: Beijing
---

## 环境

* Go 版本：1.15.6

## 起因

前一段时间，在某个 Go 交流学习群里有一个群友发出下面两段特殊的代码：

代码段 1 ：

```go
package main

import "time"

func main() {
	var i = 1
	go func() {
		time.Sleep(1*time.Second)
		println(i)
	}()
	i = 2
	for  {
	}
}
```

代码段 2 ：

```go
package main

import "time"

func main() {
	var i = 1
	go func() {
		time.Sleep(1*time.Second)
		println(i)
	}()
	i = 2
	select  {
	}
}
```

这两段程序的输出是什么？大部分人可能会觉得这两个程序会输出 2，毕竟 goroutine 在等待 1 秒钟之后才会输出 i 的值，这个时候 i = 2 这一行肯定已经执行了。但是事实是，这两段代码输出的结果不相同，代码段 1 输出的是 1，代码段 2 输出的是 2。这两段代码唯一的区别就是最后的部分，一个是 for，一个是 select，两者都会造成程序最终阻塞。

排查这个问题最容易想到的方式就是先看一下这段代码编译之后的汇编。

## 汇编代码

执行如下命令查看两者的汇编代码：

```sh
go tool compile  -S main.go
```

这里只截取代码段 1 的部分汇编：

```go
0x0024 00036 (main.go:6)        LEAQ    type.int(SB), AX
0x002b 00043 (main.go:6)        MOVQ    AX, (SP)
0x002f 00047 (main.go:6)        PCDATA  $1, $0
0x002f 00047 (main.go:6)        CALL    runtime.newobject(SB)
0x0034 00052 (main.go:6)        MOVQ    8(SP), AX
0x0039 00057 (main.go:6)        MOVQ    $1, (AX)
0x0040 00064 (main.go:7)        MOVL    $8, (SP)
0x0047 00071 (main.go:7)        LEAQ    "".main.func1·f(SB), CX
0x004e 00078 (main.go:7)        MOVQ    CX, 8(SP)
0x0053 00083 (main.go:7)        MOVQ    AX, 16(SP)
0x0058 00088 (main.go:7)        CALL    runtime.newproc(SB)
0x005d 00093 (main.go:12)       PCDATA  $1, $-1
0x005d 00093 (main.go:12)       XCHGL   AX, AX
0x005e 00094 (main.go:12)       NOP

```

可以看到，第 11 行已经被编译器优化掉了，所以代码 1 执行的结果是 1，而代码段 2 并没有被优化。

## 编译器优化部分：SSA 中间代码的生成与优化

接下来主要是研究一下这部分编译器的优化逻辑。

Go 的源代码在解析成 AST 之后，并不会直接生成目标机器代码，而是先转换成 SSA 形式的中间代码，SSA 叫做静态单赋值形式，是一种中间代码的表现形式。然后通过对中间代码一系列的优化，最终才会生成目标机器码。中间代码的生成也是我们常说的编译器前端的组成部分，也是前端处理源码的最后一步。

Go 的 SSA 中间代码形式大概如下（截取部分）：

```go
v1 (?) = InitMem <mem>
v2 (?) = SP <uintptr>
v3 (?) = SB <uintptr>
v4 (?) = Addr <*uint8> {type.int} v3
v5 (?) = OffPtr <**uint8> [0] v2
v6 (6) = Store <mem> {*uint8} v5 v4 v1
v7 (6) = StaticCall <mem> {runtime.newobject} [16] v6
```

大致意思是（从左到右）：操作类型、变量类型、函数名称、变量依赖参数等。
SSA 变量的定义在：[ssa/value.go#L19](https://github.com/golang/go/blob/release-branch.go1.15/src/cmd/compile/internal/ssa/value.go#L19)

> 基于一个适当定义的中间表示形式，可以把针对源语言 i 的前端和针对目标机器 j 的后端组合起来，构造得到源语言 i 在目标机器 j 上的一个编译器。这种创建编译器组合
> 的方法可以大大减少工作量：只要写出 m 种前段和 n 种后端处理程序，就可以得到 m*n 种编译程序。
>
>*《编译原理》第六章 中间代码的生成*

Go 也提供一个工具可以帮助我们查看代码从源码到 AST 再到最终 汇编的过程：

```sh
GOSSAFUNC=main go build main.go
```

执行之后，Go 编译器会在源码所在位置的文件夹生成一个 html 文件，其中一共记录着从源码到最后的汇编代码变化过程。

讨论代码的 SSA 中间代码(来源：[golang.design](https://golang.design/) 在线生成)：

* [代码段1](https://golang.design/gossa?id=eeac2691-6ae8-470e-9d2d-7f0de7fdb9ba)
* [代码段2](https://golang.design/gossa?id=112fc345-2027-4a82-98e6-9a3655ad20cf)

我们略过 AST 部分，直接看 `start` 也就是从 AST 到 SSA 被构建的第一步。
其中代码段 1 的 v21、v22 部分的给变量 i 赋值成 2 的中间代码已经是灰色，也就是 deadcode 无线代码。而代码段 2 则是正常的。

构建 SSA 的逻辑代码入口在 [gc/ssa.go#L296](https://github.com/golang/go/blob/release-branch.go1.15/src/cmd/compile/internal/gc/ssa.go#L296)

简单说一下 SSA 生成的规则：

例如如下代码：

```go
package test

func test1() int {
	var s = 10
	return s
}

```

变量 s 的定义对应的 SSA 如下：

```go
v5 (?) = Const64 <int> [0] // 初始化状态，s 为 0
v6 (?) = Const64 <int> [10] (s[int]) // 定义 s 为 10
```

## 其他细节

* 调试工具：dlv
* 调试 Go 编译器的时候，需要重新编译 Go 的编译器，直接安装的二进制 Go 可能没有调试信息，造成无法调试。

## 参考资料

* [https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/)
